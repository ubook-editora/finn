// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from example.djinni

#pragma once

#include "my_enum.hpp"
#include "rc.hpp"
#include <chrono>
#include <cstdint>
#include <json+extension.hpp>
#include <json.hpp>
#include <optional>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

namespace textsort {

struct  MyRecord {
    int32_t test;
    std::optional<uint32_t> test1;
    std::vector<uint32_t> test2;
    std::string test3;
    std::optional<std::string> test3_1;
    std::chrono::system_clock::time_point test4;
    std::optional<std::chrono::system_clock::time_point> test4_1;
    std::vector<uint8_t> test5;
    std::vector<std::vector<uint8_t>> test6;
    std::unordered_set<int32_t> test7;
    std::unordered_map<int32_t, std::string> test8;
    Rc test9;
    std::optional<Rc> test10;
    std::vector<Rc> test10_1;
    my_enum test11;
    std::optional<my_enum> test13;
    std::optional<int16_t> test14;
    std::vector<my_enum> test15;
    std::unordered_set<my_enum> test16;
    std::unordered_map<my_enum, int16_t> test17;

    MyRecord(int32_t test_,
             std::optional<uint32_t> test1_,
             std::vector<uint32_t> test2_,
             std::string test3_,
             std::optional<std::string> test3_1_,
             std::chrono::system_clock::time_point test4_,
             std::optional<std::chrono::system_clock::time_point> test4_1_,
             std::vector<uint8_t> test5_,
             std::vector<std::vector<uint8_t>> test6_,
             std::unordered_set<int32_t> test7_,
             std::unordered_map<int32_t, std::string> test8_,
             Rc test9_,
             std::optional<Rc> test10_,
             std::vector<Rc> test10_1_,
             my_enum test11_,
             std::optional<my_enum> test13_,
             std::optional<int16_t> test14_,
             std::vector<my_enum> test15_,
             std::unordered_set<my_enum> test16_,
             std::unordered_map<my_enum, int16_t> test17_)
    : test(std::move(test_))
    , test1(std::move(test1_))
    , test2(std::move(test2_))
    , test3(std::move(test3_))
    , test3_1(std::move(test3_1_))
    , test4(std::move(test4_))
    , test4_1(std::move(test4_1_))
    , test5(std::move(test5_))
    , test6(std::move(test6_))
    , test7(std::move(test7_))
    , test8(std::move(test8_))
    , test9(std::move(test9_))
    , test10(std::move(test10_))
    , test10_1(std::move(test10_1_))
    , test11(std::move(test11_))
    , test13(std::move(test13_))
    , test14(std::move(test14_))
    , test15(std::move(test15_))
    , test16(std::move(test16_))
    , test17(std::move(test17_))
    {}

    MyRecord() = default;
};

}  // namespace textsort


namespace nlohmann {
    template <>
    struct adl_serializer<::textsort::MyRecord>  {
        static ::textsort::MyRecord from_json(const json & j)  {
            auto result = ::textsort::MyRecord();
            if (j.contains("test")) {
                j.at("test").get_to(result.test);
            }
            if (j.contains("test1")) {
                j.at("test1").get_to(result.test1);
            }
            if (j.contains("test2")) {
                j.at("test2").get_to(result.test2);
            }
            if (j.contains("test3")) {
                j.at("test3").get_to(result.test3);
            }
            if (j.contains("test3_1")) {
                j.at("test3_1").get_to(result.test3_1);
            }
            if (j.contains("test4")) {
                j.at("test4").get_to(result.test4);
            }
            if (j.contains("test4_1")) {
                j.at("test4_1").get_to(result.test4_1);
            }
            if (j.contains("test5")) {
                j.at("test5").get_to(result.test5);
            }
            if (j.contains("test6")) {
                j.at("test6").get_to(result.test6);
            }
            if (j.contains("test7")) {
                j.at("test7").get_to(result.test7);
            }
            if (j.contains("test8")) {
                j.at("test8").get_to(result.test8);
            }
            if (j.contains("test9")) {
                result.test9 = j.at("test9").get<::textsort::Rc>();
            }
            if (j.contains("test10")) {
                j.at("test10").get_to(result.test10);
            }
            if (j.contains("test10_1")) {
                j.at("test10_1").get_to(result.test10_1);
            }
            if (j.contains("test13")) {
                j.at("test13").get_to(result.test13);
            }
            if (j.contains("test14")) {
                j.at("test14").get_to(result.test14);
            }
            if (j.contains("test15")) {
                j.at("test15").get_to(result.test15);
            }
            if (j.contains("test16")) {
                j.at("test16").get_to(result.test16);
            }
            if (j.contains("test17")) {
                j.at("test17").get_to(result.test17);
            }
            return result;
        }
        static void to_json(json & j, ::textsort::MyRecord item)  {
            j = json {
                {"test", item.test},
                {"test1", item.test1},
                {"test2", item.test2},
                {"test3", item.test3},
                {"test3_1", item.test3_1},
                {"test4", item.test4},
                {"test4_1", item.test4_1},
                {"test5", item.test5},
                {"test6", item.test6},
                {"test7", item.test7},
                {"test8", item.test8},
                {"test9", item.test9},
                {"test10", item.test10},
                {"test10_1", item.test10_1},
                {"test11", item.test11},
                {"test13", item.test13},
                {"test14", item.test14},
                {"test15", item.test15},
                {"test16", item.test16},
                {"test17", item.test17}
            }
            ;
        }
    }
    ;
}
